--################################################################################--
--##################################### NAS ####################################
--################################################################################--
-- NAS Counter Reset attack (Section 6.1.1): 
-- Property: The replay protection assures that the same NAS message is not accepted twice by the receiver.
-- The UE responds with security_mode_complete message if the amf sent security_mode_command message.
-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:=	TRUE;
-- Resultant attack: Adversary sent a replayed security_mode_command, and received security_mode_complete from the UE (traceability). Reception of complete message 
-- signifies the successful processing of security_mode_command messsage and reset the ue_nas_dl_count to 0.
-- 
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& !uederegrequested
		& sec_cap_match
		& inj_adv_act_AU != adv_AU_auth_reject
		& inj_adv_act_AU != adv_AU_reg_reject
		& inj_adv_act_AU != adv_AU_nwk_dereg_req
		& inj_adv_act_AU != adv_AU_service_reject
		& inj_adv_act_AU != adv_AU_service_accept
		& inj_adv_act_AU != adv_AU_config_update_cmd
		& inj_adv_act_AU != adv_AU_auth_req
		& inj_adv_act_AU != adv_AU_id_req
		& inj_adv_act_AU != adv_AU_nwk_dereg_accept
		& inj_adv_act_AU != adv_AU_reg_accept
		& inj_adv_act_AU != adv_AU_ue_ctx_release
	)
	->
		-- G((ue_nas_state = ue_registered
		-- & ueregcompleted
        -- & ue_nas_action = sm_complete) -> O (chan_AU = chanAU_sm_command &  amf_nas_action = sm_command)) ;
		G (((ue_nas_state = ue_registered & ueregcompleted) & ue_nas_action = sm_complete) 
			-> O (chan_AU = chanAU_sm_command & amf_nas_action = sm_command))


-- Property 7: The UE must not reset the counter while using the same security context.
-- **Property (TS 33.501, clasue 6.4.3.2):** *Replay protection shall be activated when integrity protection is 
-- activated, except when the NULL integrity protection algorithm is selected. Replay protection shall ensure that 
--- the receiver only  accepts each incoming NAS COUNT value once using the same NAS security context.*
-- Set inj_adv_UA_enabled:=	FALSE; inj_adv_AU_enabled:=	TRUE;
-- Attack: Adversary sent a replayed security_mode_command message with DL_COUNT=0 and resets 
-- the UL_COUNT and DL_COUNT of the user.
-- 
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& !uederegrequested
		& sec_cap_match
		& !amfderegrequested
		& inj_adv_act_AU != adv_AU_auth_reject
		& inj_adv_act_AU != adv_AU_reg_reject
		& inj_adv_act_AU != adv_AU_nwk_dereg_req
		& inj_adv_act_AU != adv_AU_service_reject
		& inj_adv_act_AU != adv_AU_service_accept
		& inj_adv_act_AU != adv_AU_config_update_cmd
		& inj_adv_act_AU != adv_AU_auth_req
		& inj_adv_act_AU != adv_AU_id_req
		& inj_adv_act_AU != adv_AU_nwk_dereg_accept
		& inj_adv_act_AU != adv_AU_reg_accept
		& inj_adv_act_AU != adv_AU_ue_ctx_release
	)
	->
		G (((ue_nas_state = ue_registered) & ueregcompleted) 
			-> F ((ue_nas_state = ue_registered) & (ue_nas_dl_count > 0))) ;


--------------------------------------------------------------------------------------------------------------

-- Uplink NAS Counter Desynchronization attack (Section 6.1.2): 
-- Property: The AMF correctly verifies a legitimate security_mode_complete message sent by the UE in response to a security_mode_command message sent by the AMF.
-- The UE responds with security_mode_complete message if the amf sent security_mode_command message.
-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:=	TRUE;
-- Resultant attack: Adversary crafted invalid security_mode_command messages for which the UE sends security_mode_reject message and increments UE's uplink counter.

-- 
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& ! ta_changed
		& !uederegrequested
		& sec_cap_match
		& inj_adv_act_AU != adv_AU_auth_reject
		& inj_adv_act_AU != adv_AU_reg_reject
		& inj_adv_act_AU != adv_AU_nwk_dereg_req
		& inj_adv_act_AU != adv_AU_service_reject
		& inj_adv_act_AU != adv_AU_service_accept
		& inj_adv_act_AU != adv_AU_config_update_cmd
		& inj_adv_act_AU != adv_AU_auth_req
		& inj_adv_act_AU != adv_AU_id_req
		& inj_adv_act_AU != adv_AU_nwk_dereg_accept
		& inj_adv_act_AU != adv_AU_reg_accept
		& inj_adv_act_AU != adv_AU_ue_ctx_release
	)
	->
		G (((ue_nas_state = ue_registered & ueregcompleted) & ue_nas_action = sm_complete) 
			-> O (chan_AU = chanAU_sm_command & amf_nas_action = sm_command))
-------------------------------------------------------------------------------------------------------

Exposing NAS sequence Number attack (Section 6.1.3): 

This attack has been uncovered using ProVerif. Check the ProVerif directory

-------------------------------------------------------------------------------------------------------
Neutralizing TMSI Refreshment attack (Section 6.1.4)
---Property: if UE initates service request procedure, the network will eventually perform the configuration 
-- update procedure to update the TMSI when there is no reject or equivalent message sent to the UE. 
-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:= TRUE;
-- Attack: attacker drops the configuration update command message sent by the network.
LTLSPEC
F( enable_N1 & X G (!enable_N1)) &  
(power_on & X (G !power_on)) &
G( 
	!reg_failure
	& !power_off
	& !ue_inactivity_detected
	& !smcmd_mac_failure
	& ! ta_changed
	& inj_adv_act_AU != adv_AU_auth_reject
	& inj_adv_act_AU != adv_AU_reg_reject
	& inj_adv_act_AU != adv_AU_nwk_dereg_req
	& inj_adv_act_AU != adv_AU_service_reject
	& inj_adv_act_AU != adv_AU_service_accept
	& inj_adv_act_AU != adv_AU_nwk_dereg_accept
	& inj_adv_act_AU != adv_AU_auth_req
	& inj_adv_act_AU != adv_AU_sm_command
	& inj_adv_act_AU != adv_UA_reg_complete
	& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
	& inj_adv_act_UA != adv_UA_dereg_req_switch_off
	& inj_adv_act_UA != adv_UA_service_req
	& inj_adv_act_UA != adv_UA_auth_failure_mac
	& inj_adv_act_UA != adv_UA_auth_failure_seq
	& inj_adv_act_UA != adv_UA_reg_req
	& inj_adv_act_UA != adv_UA_id_res
	& !paging_requested_bs
	& !amfderegrequested 
	& !sec_ctx_update_required
	& !uederegrequested

) ->  
 	G((ue_nas_state=ue_registered & !amf_config_updated & ue_nas_action = service_req)  -> 
	 F (ue_nas_state=ue_registered & amf_config_updated )) ;	

-- Property: If the AMF initiates configuaration update procedure, it will eventually assigns a new TMSI to the 
---- device.
-- The UE responds with security_mode_complete message if the amf sent security_mode_command message.
-- inj_adv_UA_enabled:=	TRUE;
-- inj_adv_AU_enabled:=	FALSE;
-- Attack: Adversary dropped the config_update_complete packet using null_action and caused to fail the config update procedure.
-- 
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& !uederegrequested
		& sec_cap_match
		& !service_notification
		& config_response_required 
		& inj_adv_act_UA != adv_UA_service_req
		& inj_adv_act_UA != adv_UA_reg_req
		& inj_adv_act_UA != adv_UA_dereg_req_switch_off
		& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
		& inj_adv_act_UA != adv_UA_id_res
		& inj_adv_act_UA != adv_UA_sm_complete
		& inj_adv_act_UA != adv_UA_sm_reject
		& inj_adv_act_UA != adv_UA_config_update_complete
		& inj_adv_act_UA != adv_UA_auth_failure_seq
		& inj_adv_act_UA != adv_UA_auth_failure_mac
		& inj_adv_act_UA != adv_UA_auth_response
		& inj_adv_act_UA != adv_UA_reg_complete
		
	)
	->
		G (
			((amf_nas_state = amf_registered) & (amf_nas_action = config_update_cmd)) 
			-> F (chan_UA = chanUA_config_update_complete & amf_config_updated)
		);

-- Property: If the AMF initiates configuaration update procedure, it will eventually assigns a new TMSI to the device.
-- The UE responds with security_mode_complete message if the amf sent security_mode_command message.
-- inj_adv_UA_enabled:=	TRUE;
-- inj_adv_AU_enabled:=	FALSE;
-- Attack: Adversary sent a dereg request and forced the amf to abort the cofiguration update procedure 
-- 
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& !uederegrequested
		& sec_cap_match
		& !service_notification
		& config_response_required 
		& inj_adv_act_UA != adv_UA_service_req
		& inj_adv_act_UA != adv_UA_reg_req
		& inj_adv_act_UA != adv_UA_null_action
		& inj_adv_act_UA != adv_UA_id_res
		& inj_adv_act_UA != adv_UA_sm_complete
		& inj_adv_act_UA != adv_UA_sm_reject
		& inj_adv_act_UA != adv_UA_config_update_complete
		& inj_adv_act_UA != adv_UA_auth_failure_seq
		& inj_adv_act_UA != adv_UA_auth_failure_mac
		& inj_adv_act_UA != adv_UA_auth_response
		& inj_adv_act_UA != adv_UA_reg_complete
		
	)
	->
		G (
			((amf_nas_state = amf_registered) & (amf_nas_action = config_update_cmd)) 
			-> F (chan_UA = chanUA_config_update_complete & amf_config_updated)
		);

-----------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Cutting of the Device attack (Section 6.1.5)
-- Property: If the AMF is in registered state for a UE, the amf will be in the registered state until the UE sends another registration request message.
-- inj_adv_UA_enabled:=	TRUE;
-- inj_adv_AU_enabled:=	FALSE;
-- Attack: Adversary sent a registration request messagea and detach the victim UE from the network.
-- 

LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& ! uederegrequested
		& sec_cap_match
		& inj_adv_act_UA != adv_UA_service_req
		& inj_adv_act_UA != adv_UA_dereg_req_switch_off
		& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
		& inj_adv_act_UA != adv_UA_id_res
		& inj_adv_act_UA != adv_UA_sm_complete
		& inj_adv_act_UA != adv_UA_sm_reject
		& inj_adv_act_UA != adv_UA_config_update_complete
		& inj_adv_act_UA != adv_UA_null_action
		& inj_adv_act_UA != adv_UA_auth_failure_seq
		& inj_adv_act_UA != adv_UA_auth_failure_mac
		& inj_adv_act_UA != adv_UA_auth_response
		
	)
	->
		G ((amf_nas_state = amf_registered) 
			-> F ((amf_nas_state = amf_registered) U (ue_nas_action = reg_req))) ;



-- Property: If the AMF is in registered state for a UE, the amf will be in the registered state until the UE sends another registration request message.
-- inj_adv_UA_enabled:=	TRUE;
-- inj_adv_AU_enabled:=	FALSE;
-- Attack: Adversary sent a deregistration_request message and detach the victim UE from the network.
-- 
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& ! uederegrequested
		& sec_cap_match
		& inj_adv_act_UA != adv_UA_service_req
		& inj_adv_act_UA != adv_UA_reg_req
		& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
		& inj_adv_act_UA != adv_UA_id_res
		& inj_adv_act_UA != adv_UA_sm_complete
		& inj_adv_act_UA != adv_UA_sm_reject
		& inj_adv_act_UA != adv_UA_config_update_complete
		& inj_adv_act_UA != adv_UA_null_action
		& inj_adv_act_UA != adv_UA_auth_failure_seq
		& inj_adv_act_UA != adv_UA_auth_failure_mac
		& inj_adv_act_UA != adv_UA_auth_response
		
	)
	->
		G ((amf_nas_state = amf_registered) 
			-> F ((amf_nas_state = amf_registered) U (ue_nas_action = reg_req))) ;

-- variant (Section 6.1.5): 
---Property: if UE initates registration request procedure, the network will eventually connect to the network \\
---- if it  has a valid credential
-- Set inj_adv_UA_enabled:=	FALSE; and inj_adv_AU_enabled:=	TRUE;
-- Set the inj_adv_UM_enabled=TRUE, inj_adv_act_MU =FALSE
--- Resultant attacks: (i) The fake base station recurrently sets the victim UE's reg_count=0, does not allow to 
--- downgrade to previous generations. 
--- Resultant attack: id_req auth_req id_req/id_res auth_res id_res => induces to reset the reget counter \\
-- continuous ta_change also causes the ue to reset the reget counter.
--- Impact: denial-of-service attack.

LTLSPEC
F( enable_N1 & X G (!enable_N1)) &  
(power_on & X (G !power_on)) &
G( 
	!reg_failure
	& !power_off
	& !ue_inactivity_detected
	& !smcmd_mac_failure
	& ta_changed
	& !paging_requested_bs
	& !service_notification
	& !amfderegrequested
	& inj_adv_act_AU != adv_AU_auth_reject
	& inj_adv_act_AU != adv_AU_reg_reject
	& inj_adv_act_AU != adv_AU_nwk_dereg_req
	& inj_adv_act_AU != adv_AU_service_reject
	& inj_adv_act_AU != adv_AU_service_accept
	& inj_adv_act_AU != adv_AU_config_update_cmd
	& inj_adv_act_AU != adv_AU_auth_req
	& inj_adv_act_AU != adv_AU_id_req
	& inj_adv_act_AU != adv_AU_nwk_dereg_accept
	& inj_adv_act_AU != adv_AU_reg_accept
	& inj_adv_act_AU != adv_AU_ue_ctx_release

) ->  
 	G(
		 (ue_nas_state=ue_deregistered & enable_N1)  -> 
	 	(F (ue_nas_state=ue_registered)) 
	 );


---- =========================================================================================
-- Denial-of-Service attack
-- Property: if UE FSM is in deregistered state, the UE will eventually move to the register_initiated and UE authenticates MME.
-- Set inj_adv_UA_enabled:=	TRUE; inj_adv_AU_enabled:=	FALSE;
--- Resultant attacks: (i) DoS attacks with reg_reject, service_reject, auth_reject, ue initiated dereg_req
LTLSPEC
F( enable_N1 & X G (!enable_N1)) &  
(power_on & X (G !power_on)) &
G( 
	!reg_failure
	& !power_off
	& !ue_inactivity_detected
	& !smcmd_mac_failure
	& ! ta_changed
	& inj_adv_act_AU != adv_AU_auth_reject
	& inj_adv_act_AU != adv_AU_reg_reject
	& inj_adv_act_AU != adv_AU_nwk_dereg_req
	& inj_adv_act_AU != adv_AU_service_reject
	& inj_adv_act_AU != adv_AU_service_accept
	& inj_adv_act_AU != adv_AU_nwk_dereg_accept
	& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
	& inj_adv_act_UA != adv_UA_dereg_req_switch_off
	& inj_adv_act_UA != adv_UA_service_req
	& inj_adv_act_UA != adv_UA_auth_failure_mac
	& inj_adv_act_UA != adv_UA_auth_failure_seq
	& inj_adv_act_UA != adv_UA_reg_req
	& inj_adv_act_UA != adv_UA_null_action
	-- & inj_adv_act_UA != 
	-- & inj_adv_act_UA != 
	& !paging_requested_bs
	& !service_notification
	& !amfderegrequested
) ->  
 	G(ue_nas_state=ue_deregistered  -> (F (ue_nas_state=ue_reg_inited & ue_partial_sec_ctx_exist ))) ;	


-------------------------------------------------------------------------------------------------------
--- Denial-of-service attack in case of configuration update procedure.
---Property: if UE initates service request procedure, the network will eventually perform the configuration 
-- update procedure to update the TMSI.
-- Set inj_adv_UA_enabled:=	TRUE; inj_adv_AU_enabled:=	FALSE;
--- Set the inj_adv_UM_enabled=TRUE, inj_adv_act_MU =FALSE
--- Resultant attacks: (i) DoS attacks with reg_reject, service_reject, auth_reject, ue initiated dereg_req
LTLSPEC
F( enable_N1 & X G (!enable_N1)) &  
(power_on & X (G !power_on)) &
G( 
	!reg_failure
	& !power_off
	& !ue_inactivity_detected
	& !smcmd_mac_failure
	& ! ta_changed
	& inj_adv_act_AU != adv_AU_auth_reject
	& inj_adv_act_AU != adv_AU_reg_reject
	& inj_adv_act_AU != adv_AU_nwk_dereg_req
	& inj_adv_act_AU != adv_AU_service_reject
	& inj_adv_act_AU != adv_AU_service_accept
	& inj_adv_act_AU != adv_AU_nwk_dereg_accept
	& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
	& inj_adv_act_UA != adv_UA_dereg_req_switch_off
	& inj_adv_act_UA != adv_UA_service_req
	& inj_adv_act_UA != adv_UA_auth_failure_mac
	& inj_adv_act_UA != adv_UA_auth_failure_seq
	& inj_adv_act_UA != adv_UA_reg_req
	& inj_adv_act_UA != adv_UA_null_action
	-- & inj_adv_act_UA != 
	-- & inj_adv_act_UA != 
	& !paging_requested_bs
	& !service_notification
	& !amfderegrequested
) ->  
 	G((ue_nas_state=ue_registered & !amf_config_updated & ue_nas_action = ue_service_req)  -> 
	 (F (ue_nas_state=ue_registered & amf_config_updated )) ;	

--------------------------------------------------------------------------------------------------
Traceability attack (similar to prior attack)
-- Property: The UE responds with security_mode_complete message if the amf sent security_mode_command message.
-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:=	TRUE;
-- Attack: Adversary sent a replayed auth_request, and received auth_response from the UE (traceability).
-- 

-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:= TRUE;
LTLSPEC
	F (enable_N1 & X G (!enable_N1)) &  
	  (power_on & X (G !power_on)) &
	G( 	!reg_failure
		& !power_off
		& !ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& !uederegrequested
		& sec_cap_match
		& !amfderegrequested
		& inj_adv_act_AU != adv_AU_auth_reject
		& inj_adv_act_AU != adv_AU_reg_reject
		& inj_adv_act_AU != adv_AU_nwk_dereg_req
		& inj_adv_act_AU != adv_AU_service_reject
		& inj_adv_act_AU != adv_AU_service_accept
		& inj_adv_act_AU != adv_AU_config_update_cmd
		& inj_adv_act_AU != adv_AU_sm_command
		& inj_adv_act_AU != adv_AU_id_req
		& inj_adv_act_AU != adv_AU_nwk_dereg_accept
		& inj_adv_act_AU != adv_AU_reg_accept
		& inj_adv_act_AU != adv_AU_ue_ctx_release
		& inj_adv_act_UA != adv_UA_null_action

	)
	->
		G (((ue_nas_state = ue_reg_inited & ue_partial_sec_ctx_exist) & ue_nas_action = auth_response) 
			-> O (chan_AU = chanAU_auth_req & amf_nas_action = auth_req));


-----------------------------------------TODO: need to fix mme_seq ---------------------
Property: If the UE initiates registration procedure, it will eventually establishes the partial security context.
-- inj_adv_UA_enabled:=	TRUE;
-- inj_adv_AU_enabled:=	FALSE;
-- Attack: Authentication Synch Failure Attack.
LTLSPEC
G !(enable_N1 & power_on) &
F( enable_N1 & X G (!enable_N1)) &  
(power_on & X (G !power_on)) &
G( 
	!reg_failure
	& !power_off
	& !ue_inactivity_detected
	& !smcmd_mac_failure
	& ! ta_changed
	& inj_adv_act_AU != adv_AU_auth_reject
	& inj_adv_act_AU != adv_AU_reg_reject
	& inj_adv_act_AU != adv_AU_nwk_dereg_req
	& inj_adv_act_AU != adv_AU_service_reject
	& inj_adv_act_AU != adv_AU_service_accept
	& inj_adv_act_AU != adv_AU_nwk_dereg_accept
	& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
	& inj_adv_act_UA != adv_UA_dereg_req_switch_off
	& inj_adv_act_UA != adv_UA_service_req
	& inj_adv_act_UA != adv_UA_auth_failure_mac
	& inj_adv_act_UA != adv_UA_auth_failure_seq
	& inj_adv_act_UA != adv_UA_reg_req
	& inj_adv_act_UA != adv_UA_null_action
	-- & inj_adv_act_UA != 
	-- & inj_adv_act_UA != 
	& !paging_requested_bs
	& !service_notification
	& !amfderegrequested
) ->  
 	G(ue_nas_state=ue_deregistered  -> (F (ue_nas_state=ue_reg_inited & ue_partial_sec_ctx_exist ))) ;

------------------------------------------------------------------------------------------------------------
---Property 11: if UE initates service request procedure, the network will eventually perform the configuration 
-- update procedure to update the TMSI.
-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:=	TRUE;
--- Set the inj_adv_UM_enabled=TRUE, inj_adv_act_MU =FALSE
--- Resultant attacks: (i) DoS attacks with reg_reject, service_reject, auth_reject, ue initiated dereg_req
LTLSPEC
F( enable_N1 & X G (!enable_N1)) &  
(power_on & X (G !power_on)) &
G( 
	!reg_failure
	& !power_off
	& !ue_inactivity_detected
	& !smcmd_mac_failure
	& ! ta_changed
	& !paging_requested_bs
	& !service_notification
	& !amfderegrequested
) ->  
 	G((ue_nas_state=ue_registered & !amf_config_updated & ue_nas_action = ue_service_req)  -> 
	 (F (ue_nas_state=ue_registered & amf_config_updated )) ;	




---------------------------------------------------------------------------------------------------------------
-- Property: If AMF wants to setup a security context, the UE will eventually set up/update its security context.
-- inj_adv_UA_enabled:=	FALSE;
-- inj_adv_AU_enabled:=	TRUE;
-- counter-example: UE gets registered, but there is not security context established
-- Attack: Adversary can force a device to connect to the fake network while setting up the connection with NEA0 
-----and NIA0 
-- NOTE: This attack will fail if the UE ensures that NEA0 and NIA0 can only be chosen in case of 
--	emergency bearer setup.
LTLSPEC
	G(	!reg_failure
		& !power_off
		& X(!power_on)
		&!ue_inactivity_detected
		& !smcmd_mac_failure
		& ! ta_changed
		& inj_adv_act_AU != adv_AU_auth_reject
		& inj_adv_act_AU != adv_AU_reg_reject
		& inj_adv_act_AU != adv_AU_nwk_dereg_req
		& inj_adv_act_AU != adv_AU_service_reject
		& inj_adv_act_AU != adv_AU_service_accept
		& inj_adv_act_AU != adv_AU_nwk_dereg_accept
		& inj_adv_act_UA != adv_UA_dereg_req_not_switch_off
		& inj_adv_act_UA != adv_UA_dereg_req_switch_off
		& inj_adv_act_UA != adv_UA_service_req
		& inj_adv_act_UA != adv_UA_auth_failure_mac
		& inj_adv_act_UA != adv_UA_auth_failure_seq
		-- & inj_adv_act_UA != 
		-- & inj_adv_act_UA != 
		& !paging_requested_bs
		& !service_notification
		& !amfdereg_requested
	)
	->
		G((amf_nas_action=sm_command)
		-> (F (ue_sec_ctx_updated & ue_complete_sec_ctx_exist))) ;

----------------------------------------------------------------------------------------------------


--- ################################################################################################---
------------------------------------------------ RRC Layers -------------------------------------------
--- ################################################################################################---
---------------------------------------------------------------------------------------------
-- Denial-of-Service attack with rrc_setup_req(Section 6.2.1):
-- Property: If the base station has a rrc security context in the current state, it will exist forever unless 
----there is a request for nas_con_establishment from a UE.
-- Set the inj_adv_UB_enabled=TRUE, inj_adv_act_BU = TRUE
-- Resultant attack: The adversary sends fake rrc_resume_req or rrc_reestab_req message for which the mac_verfication
-- fails and deletes the security context at the base station.
-- Impact: Denial-of-Service attack.

LTLSPEC
--F( nas_requested_con_establishment & X G (!nas_requested_con_establishment)) &   
G(  
    !dl_info_transfer_required &
    !nas_requested_con_reestablishment &
    !paging_timer_expired &
    inj_adv_act_BU != adv_BU_rrc_reject &
    inj_adv_act_BU != adv_BU_paging_tmsi &
    inj_adv_act_BU != adv_BU_paging_irnti &
    inj_adv_act_BU != adv_UB_rrc_reestab_req &
    inj_adv_act_UB != adv_UB_rrc_resume_complete &
    inj_adv_act_UB != adv_UB_rrc_setup_req &
    inj_adv_act_UB != adv_UB_rrc_setup_complete &
    inj_adv_act_UB != adv_UB_rrc_reestab_req &
    inj_adv_act_UB != adv_UB_rrc_reestab_complete &
    inj_adv_act_UB != adv_UB_ul_info_transfer &
    inj_adv_act_UB != adv_UB_ul_user_data &
    inj_adv_act_UB != adv_UB_null_action 
    
) ->
G
( 
	ue_rrc_sec_ctx_exist -> 
	X 
	(
		G(ue_rrc_sec_ctx_exist) | (ue_rrc_sec_ctx_exist U nas_requested_con_establishment)
  	)
)

---------------------------------------------------------------------------------------------

-- Attack  (Section 6.2.1)-Variant: 
--- Property: If the UE has a rrc security context in the current state, it will exist forever unless 
-- there is a request for nas/rrc connection establishment.
-- Instruction: Set the inj_adv_UB_enabled=TRUE, inj_adv_act_BU = TRUE
-- Resultant attack: The adversary sends rrc_setup message in response to the rrc_resume_req/rrc_reestab_req 
-- message, which induce the UE to delete its previous sec_ctx. 
-- Impact: Denial-of-Service attack.


LTLSPEC
--F( nas_requested_con_establishment & X G (!nas_requested_con_establishment)) &   
G(  
    !dl_info_transfer_required &
    !nas_requested_con_reestablishment &
    !paging_timer_expired &
    inj_adv_act_BU != adv_BU_rrc_reject &
    inj_adv_act_BU != adv_BU_paging_tmsi &
    inj_adv_act_BU != adv_BU_paging_irnti &
    inj_adv_act_BU != adv_UB_rrc_reestab_req &
    inj_adv_act_UB != adv_UB_rrc_resume_complete &
    inj_adv_act_UB != adv_UB_rrc_setup_req &
    inj_adv_act_UB != adv_UB_rrc_setup_complete &
    inj_adv_act_UB != adv_UB_rrc_reestab_req &
    inj_adv_act_UB != adv_UB_rrc_reestab_complete &
    inj_adv_act_UB != adv_UB_ul_info_transfer &
    inj_adv_act_UB != adv_UB_ul_user_data &
    inj_adv_act_UB != adv_UB_null_action 
    
) ->
G
( 
	ue_rrc_sec_ctx_exist -> 
	X 
	(
		G(ue_rrc_sec_ctx_exist) | (ue_rrc_sec_ctx_exist U nas_requested_con_establishment)
  	)
)

---------------------------------------------------------------------------------------------
-- Installing null-cipher and null-integrity attack - part 1 (section 6.2.2): 
-- Property: If the UE requires the AS security context to be setup, the UE will eventually establish the security context.
-- Instruction: Set the inj_adv_UB_enabled=TRUE, inj_adv_act_BU = FALSE
-- Resultant attacks/counter-example: Forcing to use null_integrity protection using security_mode_failure message sent by the fake UE. 
----	The null security context will be established eventually.


LTLSPEC
F( nas_requested_con_establishment & X G (!nas_requested_con_establishment)) &   
G( 	
	!dl_info_transfer_required &
	!nas_requested_con_reestablishment &
	!paging_timer_expired &
	!inj_adv_BU_enabled &
	inj_adv_act_BU != adv_BU_rrc_reject &
	inj_adv_act_BU != adv_BU_paging_tmsi &
	inj_adv_act_BU != adv_BU_paging_irnti &
	inj_adv_act_BU != adv_UB_rrc_reestab_req &
	inj_adv_act_UB != adv_UB_rrc_resume_complete &
	inj_adv_act_UB != adv_UB_rrc_setup_req &
	inj_adv_act_UB != adv_UB_rrc_setup_complete &
	inj_adv_act_UB != adv_UB_rrc_reestab_req &
	inj_adv_act_UB != adv_UB_rrc_reestab_complete &
	inj_adv_act_UB != adv_UB_ul_info_transfer &
	inj_adv_act_UB != adv_UB_ul_user_data &
	inj_adv_act_UB != adv_UB_null_action 
 	
) ->
(G (!ue_rrc_sec_ctx_exist & as_sec_ctx_setup_required)  
	-> F (ue_rrc_sec_ctx_exist));

---------------------------------------------------------------------------------------------------------
-- Installing null-cipher and null-integrity attack - part 2 (section 6.2.2): 
--Property 2: If the base station requires the AS security context to be setup, the base station 
-- will eventually establish the security context.
-- Set the inj_adv_UB_enabled=TRUE, inj_adv_act_BU = FALSE
-- Resultant attacks/counter-example: Forcing the base station to use null_integrity protection using security_mode_failure message sent by the fake UE. The null security context will be established eventually.
-- Section 6.2.2: Installing null cipher and null integrity attack.


LTLSPEC
F( nas_requested_con_establishment & X G (!nas_requested_con_establishment)) &   
G( 	
	!dl_info_transfer_required &
	!nas_requested_con_reestablishment &
	!paging_timer_expired &
	!inj_adv_BU_enabled &
	inj_adv_act_BU != adv_BU_rrc_reject &
	inj_adv_act_BU != adv_BU_paging_tmsi &
	inj_adv_act_BU != adv_BU_paging_irnti &
	inj_adv_act_BU != adv_UB_rrc_reestab_req &
	inj_adv_act_UB != adv_UB_rrc_resume_complete &
	inj_adv_act_UB != adv_UB_rrc_setup_req &
	inj_adv_act_UB != adv_UB_rrc_setup_complete &
	inj_adv_act_UB != adv_UB_rrc_reestab_req &
	inj_adv_act_UB != adv_UB_rrc_reestab_complete &
	inj_adv_act_UB != adv_UB_ul_info_transfer &
	inj_adv_act_UB != adv_UB_ul_user_data &
	inj_adv_act_UB != adv_UB_null_action 
 	
) ->
(G (!gnb_rrc_sec_ctx_exist & as_sec_ctx_setup_required)  
	-> F (gnb_rrc_sec_ctx_exist));

---------------------------------------------------------------------------------------------
--- Property: The base station responds with a rrc_resume message if 
--- and only if the base station receives a valid rrc_resume_req message.
-- inj_adv_UB_enabled:=	TRUE;
-- inj_adv_BU_enabled:=	FALSE;
--- Counter-example: If fake UE sends rrc_resume_req message, it received rrc_setup message.
--- Attack from symbolic model checker: Traceability/linkability (Cell-level location tracking)
---- This attack cannot be realized because ProVerif did not generate a counter-example for this. Since rrc_resume_req message has MAC verification, the base station could not verify the MAC sent by the attacker.
LTLSPEC 
 G (
	!ul_data_transfer_required & 
	!ul_transfer_required &
    !ue_cap_required &
	inj_adv_act_BU != adv_BU_rrc_reject &
	inj_adv_act_BU != adv_BU_paging_tmsi &
	inj_adv_act_BU != adv_BU_paging_irnti &
	inj_adv_act_UB != adv_UB_rrc_resume_req &
	inj_adv_act_UB != adv_UB_rrc_setup_req &
	inj_adv_act_UB != adv_UB_rrc_setup_complete &
	inj_adv_act_UB != adv_UB_rrc_reestab_req &
	inj_adv_act_UB != adv_UB_rrc_reestab_complete &
	inj_adv_act_UB != adv_UB_ul_info_transfer &
	inj_adv_act_UB != adv_UB_ul_user_data &
	inj_adv_act_UB != adv_UB_null_action & 
	inj_adv_act_UB != adv_UB_rrc_sm_complete & 
	inj_adv_act_UB != adv_UB_rrc_sm_failure &
	inj_adv_act_UB != adv_UB_ue_cap_info
 ) ->
G ((bs_rrc_state=gnb_rrc_inactive & chan_UB = chanUB_rrc_resume_req)  
	-> X (chan_BU = chanBU_rrc_resume));


--------------------------------------------------------------------------------------------
--- Lullaby attack (Section 6.2.3): 
--- Property 6: If a ue is in rrc_connected state and the base station sends 
--- rrc_reconf message, it will remain in the rrc_connected state.
--- Set the inj_adv_UB_enabled=FALSE and inj_adv_act_BU = TRUE
--- Resultant attacks: Denial of service with rrc_release.
--- Vertion 1: 
LTLSPEC 
G ((ue_rrc_state=ue_rrc_connected & bs_rrc_action = rrc_reconf)  
	-> X (G ue_rrc_state = ue_rrc_connected));

--- Resultant attacks: Denial of service with rrc_release.
--- Vertion 2: 
LTLSPEC 
G (
	inj_adv_act_BU != adv_BU_rrc_release & 
	inj_adv_act_BU != adv_BU_rrc_release_suspend &
	inj_adv_act_BU != adv_BU_paging_irnti &
	inj_adv_act_BU != adv_BU_paging_tmsi 
	
) ->
G ((ue_rrc_state=ue_rrc_connected & bs_rrc_action = rrc_reconf)  
	-> X (G ue_rrc_state = ue_rrc_connected));

--------------------------------------------------------------------------------------------
--- Lullaby attack (Section 6.2.3) Variant
--- Property: If a ue is in rrc_connected state and the base station sends 
--- rrc_reconf message, it will remain in the rrc_connected state.
--- Set the inj_adv_UB_enabled=FALSE and inj_adv_act_BU = TRUE
--- Resultant attacks: Denial of service with rrc_release.
--- Vertion 1: 
LTLSPEC 
G ((ue_rrc_state=ue_rrc_connected & bs_rrc_action = rrc_reconf)  
	-> X (G ue_rrc_state = ue_rrc_connected));

--- Resultant attacks: Denial of service with rrc_release.
--- Vertion 2: 
LTLSPEC 
G (
	inj_adv_act_BU != adv_BU_rrc_release & 
	inj_adv_act_BU != adv_BU_rrc_release_suspend &
	inj_adv_act_BU != adv_BU_paging_irnti &
	inj_adv_act_BU != adv_BU_paging_tmsi 
	
) ->
G ((ue_rrc_state=ue_rrc_connected & bs_rrc_action = rrc_reconf)  
	-> X (G ue_rrc_state != ue_rrc_idle));


--------------------------------------------------------------------------------------------
--- Incarceration attack with rrc_reject and rrc_release (Section 6.2.4):
--- Property: If the base station is in rrc_connected state, it will remain in the connected state 
-- until ue's nas requested connection establishment.
--- Set the inj_adv_UB_enabled=FALSE and inj_adv_act_BU = TRUE
--- Resultant attacks: Denial of service with rrc_release/rrc_reject.


LTLSPEC 
G (
	inj_adv_act_BU != adv_BU_rrc_release & 
	inj_adv_act_BU != adv_BU_rrc_release_suspend &
	inj_adv_act_BU != adv_BU_paging_irnti &
	inj_adv_act_BU != adv_BU_paging_tmsi 
) ->
G ((bs_rrc_state = bs_rrc_connected)  
	-> X (G bs_rrc_state != bs_rrc_idle) U nas_requested_con_establishment);

--################################################################################--
--################################### CROSS-LAYER #################################
--################################################################################
----------------------------------------------------------------------------------------
--- Exposing Device's TMSI and paging occasion (Section 6.3.1):
--- Property: If paging_tmsi is sent in the current state, it implies that in the 
--- previous state there was no paging_tmsi since dl_info_transfer_required 
--- was true. In another words: paging_tmsi will be sent just once between two incoming service notifications.
--- Resultant attack: TMSI exposure
LTLSPEC
G 	(
		!nas_requested_con_establishment
		& inj_adv_act_BU != adv_BU_rrc_reject
		& inj_adv_act_BU != adv_BU_rrc_release
		-- need to check if any other counter-example needs to be added
	) ->
	G( ue_rrc_state = ue_rrc_idle & chan_BU=chanBU_paging_tmsi ->
		Y ((chan_BU != chanBU_paging_tmsi) S dl_info_transfer_required)
	);

-------------------------------------------------------------------------------------------
--- Exposing Device's IRNTI (Section 6.3.2):
--- Property: If paging_irnti is sent in the current state, it implies that in the 
--- previous state there was no paging_irnti and nas requested connection establishment  
--- was true.
--- In another words: paging_irnti will be sent just once between two incoming service notifications/
--- inj_adv_UB_enabled:=	FALSE;
--- inj_adv_BU_enabled:=	TRUE;
--- Attack: C-IRNTI exposure
LTLSPEC
G 	(
		!dl_info_transfer_required
		& inj_adv_act_BU != adv_BU_rrc_reject
		& inj_adv_act_BU != adv_BU_rrc_release
		-- need to check if any other counter-example needs to be added
	) ->
	G( ue_rrc_state = ue_rrc_inactive & chan_BU=chanBU_paging_irnti ->
		Y ((chan_BU != chanBU_paging_irnti) S nas_requested_con_establishment)
	);
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

----------------------------------------------TODO-----------------------------------------------
--- Property 12: TODO: If he base station requires to set up a bearer, it will eventually set up the 
--- bearer after establishing the security context
--- inj_adv_UB_enabled:=	TRUE;
--- inj_adv_BU_enabled:=	FALSE;
-- TODO: Need to discuss.
LTLSPEC
G 	(	
		X (!nas_requested_con_establishment)
		& !dl_info_transfer_required
		& !idle_mode_required
		& !ul_transfer_required
		& !nas_requested_con_reestablishment
		& inj_adv_act_UB != adv_UB_rrc_setup_req
		& inj_adv_act_UB != adv_UB_rrc_resume_req
		& inj_adv_act_UB != adv_UB_rrc_reestab_req
		& inj_adv_act_UB != adv_UB_ul_info_transfer
		& inj_adv_act_UB != adv_UB_ue_cap_info
		-- need to check if any other counter-example needs to be added
	) ->
	--G( (ue_rrc_state = ue_rrc_connected & chan_UB=chanUB_rrc_sm_complete) ->
	--	O((chan_BU!=chanBU_rrc_sm_command) S (as_sec_ctx_setup_required))
	--);
	G( 
		(bs_rrc_state = gnb_rrc_connected & !gnb_rrc_sec_ctx_exist & 
		!gnb_bearer_established & gnb_bearer_setup_required) 
			->  F(gnb_bearer_established & gnb_rrc_sec_ctx_exist)
	);

-
	);

--------------------------------------------TODO------------------------------------------------------------
--- Property 13: The base station willl not have the same pdcp counter more than once. In other words,
--- if the pdcp counter is already greater than 0, it will never reset to 0.
--- inj_adv_UB_enabled:=	FALSE;
--- inj_adv_BU_enabled:=	FALSE;
-- Attack: reset the counter.
LTLSPEC
-- G 	(	
-- 		X (!nas_requested_con_establishment)
-- 		-- need to check if any other counter-example needs to be added
-- 	) ->
	G( 
		(bs_rrc_state = gnb_rrc_connected & gnb_rrc_sec_ctx_exist & 
		(gnb_pdcp_dl_count > 0)) 
			->  F (bs_rrc_state = gnb_rrc_connected & gnb_pdcp_dl_count !=0)
	);

---------------------------------------------TODO:------------------------------------------------------
--- Property 14: If a UE is in connected state, it will respond with 
--- ue_cap_info message if it receives ue_cap_enquiry message and has the security context 
--- inj_adv_UB_enabled:=	TRUE;
--- inj_adv_BU_enabled:=	FALSE;
--- Attack: Forcing a UE to expose ue_cap_info in plaintext
LTLSPEC
	G( 
		(ue_rrc_state = ue_rrc_connected & ue_rrc_action = ue_cap_info) 
			->  (ue_rrc_sec_ctx_exist & chan_BU=chanBU_ue_cap_enquiry)
	);		



