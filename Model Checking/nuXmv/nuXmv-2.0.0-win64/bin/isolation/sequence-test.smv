MODULE main

VAR

-------------------- Environmental variables ----------------------- 
user_request : boolean;  --client side 
processing_done : boolean ; --server side 
processing_error: boolean ; --server side 

--client_ev : {RESPONSE, RESET, NULL} ; --client side events 
--server_ev: {REQUEST, FATAL_ERROR, NULL} ; --server side  events 

attacker_inject_message_chanCS	:	boolean	;
attacker_inject_message_chanSC	:	boolean	;

--client_seq: integer ; 
--server_seq : integer ; 

client_seq: unsigned word[32] ; 
server_seq : unsigned word[32] ; 
two: unsigned word[32] ; 
one: unsigned word[32] ; 
zero: unsigned word[32] ; 


client_state : {
        CLIENT_ERROR, 
        CLIENT_READY, 
        CLIENT_PROCESSING
        };
client_action: {
    CLIENT_REQUEST, 
    CLIENT_FATAL_ERROR, 
    CLIENT_NULL_ACTION};



server_state: {
        SERVER_READY, 
        SERVER_PROCESSING, 
        SERVER_ERROR
        };
server_action: {
    SERVER_RESPONSE, 
    SERVER_RESET, 
    SERVER_NULL_ACTION
    };



--------------- Adversarial channel from client to server ---------------

chan_CS	:
{
	chanCS_request,
	chanCS_okay,
	chanCS_fatal_error,
	chanCS_null_action
};

--------------- Adversarial channel from MME to UE ---------------

chan_SC	:
{
	chanSC_response,
	chanSC_reset,
	chanSC_null_action
};

--------------- Injection adversary action for channel chan_client_to_server ---------------

inj_adv_act_CS	:
{
	adv_CS_request,
	adv_CS_fatal_error,
    adv_CS_null_action
};

--------------- Injection adversary action for channel chan_server_to_client ---------------

inj_adv_act_SC	:
{
	adv_SC_response,
    adv_SC_reset,
    adv_SC_null_action
};

-------------------------------------------------- DEFINE ----------------------------
DEFINE 

--client transitions 
ct1:= client_state = CLIENT_READY & user_request ; 
ct2 := client_state = CLIENT_PROCESSING & chan_SC = chanSC_response ; 
ct3 := client_state = CLIENT_PROCESSING & chan_SC = chanSC_reset ; 
ct4 := client_state = CLIENT_READY & chan_SC = chanSC_reset ; 

-- server transitions
st0 := chan_CS = chanCS_fatal_error; 
st1 := server_state = SERVER_READY & chan_CS = chanCS_request ; 
st2 := server_state = SERVER_PROCESSING & processing_error ; 
st3 := server_state = SERVER_PROCESSING & processing_done ; 
st4 := server_state = SERVER_PROCESSING & chan_CS = chanCS_fatal_error ;
st5 := server_state = SERVER_ERROR & chan_CS = chanCS_fatal_error ;
-------------------------------------------------------
noisy_channel_client_to_server:=	FALSE;
noisy_channel_server_to_client:=	FALSE;

--inj_adv_CS_enabled:=	TRUE;
--inj_adv_SC_enabled:=	TRUE;


inj_adv_CS_enabled:=	FALSE;

---------------------------- CHaNGE THE FOLLOWING FROM TRUE TO FALSE TO BLOCK ATTACK --------------------------------------------------------
inj_adv_SC_enabled:=	TRUE;


----------------------------------------------- ASSIGN ----------------------------------
ASSIGN

two := 0d32_2 ; 
one := 0d32_1 ; 
zero := 0d32_0 ; 

-- clients next state
init(client_state) := CLIENT_READY; 
next (client_state) :=
case 
	ct1 : CLIENT_PROCESSING ;
	ct2 | ct3 : CLIENT_READY ;
	ct4: CLIENT_ERROR ;
	TRUE : client_state ;   
esac ; 

-- clients action
init(client_action) := CLIENT_NULL_ACTION;
next(client_action) := 
case 
	ct1 : CLIENT_REQUEST ;
	--ct2 | ct3 : OKAY 
	ct4 : CLIENT_FATAL_ERROR ;
	TRUE : CLIENT_NULL_ACTION ;
esac ; 

-- server's next state
init( server_state ) := SERVER_READY ;
next(server_state) := 
case
	st0 | st4 | st5 : SERVER_ERROR ;
	st1 : SERVER_PROCESSING ;
	st2 | st3 : SERVER_READY ; 
	TRUE: server_state ; 
esac ; 

-- server's action
init(server_action) := SERVER_NULL_ACTION ;
next(server_action) := 
case 
	st0 | st1 : SERVER_NULL_ACTION ; 
	st2 : SERVER_RESET ; 
	st3 : SERVER_RESPONSE ; 
	TRUE : SERVER_NULL_ACTION ; 
esac ; 


init(chan_CS)	:=	chanCS_null_action;

next(chan_CS)	:=	 case
attacker_inject_message_chanCS	 &	inj_adv_CS_enabled	&	inj_adv_act_CS	=	adv_CS_request	:	chanCS_request	;
--attacker_inject_message_chanCS	&	inj_adv_CS_enabled	&	inj_adv_act_CS	=	adv_CS_okay	:	chanCS_okay	;
attacker_inject_message_chanCS	&	inj_adv_CS_enabled	&	inj_adv_act_CS	=	adv_CS_fatal_error	:	chanCS_fatal_error	;
attacker_inject_message_chanCS	&	inj_adv_CS_enabled	&	inj_adv_act_CS	=	adv_CS_null_action	:	chanCS_null_action ;

------------- The following is wrong -------------
------------- In this case, the client action should be forwarded to the server -------------
------------- Here you are choosing some random value from the set --------------------------
---TRUE	:
---{
--	chanCS_request,
--	chanCS_fatal_error,
--    chanCS_null_action
--}	;

-------------- The fix is here -------------------

client_action = CLIENT_REQUEST : {chanCS_request};
client_action = CLIENT_FATAL_ERROR : {chanCS_fatal_error};
client_action = CLIENT_NULL_ACTION : {chanCS_null_action} ; 
TRUE : {chanCS_null_action};
-------------- We could have merged the above two lines to have only the following ------------------
--------- TRUE : {chanCS_null_action};

esac	;


init(chan_SC)	:=	chanSC_null_action;

next(chan_SC)	:=	 case
attacker_inject_message_chanSC	&	inj_adv_SC_enabled	&	inj_adv_act_SC	=	adv_SC_response 	:	chanSC_response	;
attacker_inject_message_chanSC	&	inj_adv_SC_enabled	&	inj_adv_act_SC	=	adv_SC_reset 	:	chanSC_reset	;
attacker_inject_message_chanSC	&	inj_adv_SC_enabled	&	inj_adv_act_SC	=	adv_SC_null_action 	:	chanSC_null_action;
------------- The following is wrong -------------
------------- In this case, the server action should be forwarded to the client -------------
------------- Here you are choosing some random value from the set --------------------------
--TRUE	:
--{
--	chanSC_response,
--	chanSC_reset,
--    chanSC_null_action
--}	;

-------------- The fix is here -------------------
server_action = SERVER_RESPONSE : {chanSC_response} ; 
server_action = SERVER_RESET : {chanSC_reset}  ; 
server_action = SERVER_NULL_ACTION : {chanSC_null_action};
TRUE : {chanSC_null_action};

-------------- We could have merged the above two lines to have only the following ------------------
--------- TRUE : {chanSC_null_action};


esac	;


init(client_seq) := zero;
next(client_seq) :=
case 
	ct1 | ct2 | ct3  : client_seq + one ;
        --ct1  : client_seq + one 
	TRUE: client_seq ;
esac ; 


init(server_seq) := zero;
next(server_seq ) := 
case 
	st1 | st2 | st3 : server_seq + one ;
        --st2 := server_seq + one 
	TRUE : server_seq ;
esac ; 

--LTLSPEC G(chan_SC = chanSC_reset -> client_seq mod two != zero ) ;
LTLSPEC (client_state = -> client_seq mod two != zero ) ;